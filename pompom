#! /bin/bash

set -o errexit -o nounset -o pipefail

# Default arguments.
COMMAND="${1:-start}"
COMMANDTYPE="${2:-work}"

# Various state and config files.
PIDFILE="/tmp/.pom-pid"
STATEFILE="/tmp/.pom-state"
CONFIGFILE="~/.pomconfig"

# Set a nice name for easy referencing.
SELF="$(basename "${0}")"

# Default intervals are 25 minutes and 5 minutes.
WORKINTERVAL=$(( 60 * 25 ))
BREAKINTERVAL=$(( 60 * 5 ))

#_cleanup()
#{
#	echo "quitting pompom"
#	rm "${PIDFILE}"
#	exit
#}
#
## @todo Is this pointless now?
#trap _cleanup SIGTERM

_say()
{
	# @todo Add support for OSX say command
	spd-say "${1}" --voice-type "female3"
}

_terminate()
{
	echo "${1}" 1>&2
	exit 1
}

_savepid()
{
	echo "${1}" > "${PIDFILE}"
	echo "Saving pid ${1}"
}

_rmpid()
{
	[[ -e "${PIDFILE}" ]] && rm "${PIDFILE}"
}

_setstate()
{
	local TS REMAINING END
	TS="$(date +%s)"
	REMAINING="${3}"
	END=$(( TS + REMAINING ))

	echo "" > "${STATEFILE}"
	echo "OP=${1}" >> "${STATEFILE}"
	echo "END=${END}" >> "${STATEFILE}"
	echo "STATE=${2}" >> "${STATEFILE}"
	echo "REMAINING=${REMAINING}" >> "${STATEFILE}"
}

_rmstate()
{
	[[ -e "${STATEFILE}" ]] && rm "${STATEFILE}"
}

# @todo Check for existence of statefile?
_getstate()
{
	[[ -e "${STATEFILE}" ]] && source "${STATEFILE}"
}

# Test for the case where the command has been independently killed but we still
# have the PIDFILE.
#
# This is slightly convoluted, but lets us check for instances of pompom
# which aren't the currently running process.
# @todo there must be a better way...
if [[ "$(pgrep -c "${SELF}")" -eq 1 && -e "${PIDFILE}" ]]
then
	echo "Removing pid"
	_rmpid
	_rmstate
fi

case "${COMMAND}" in
	start )
		# Check for the case where we have a $PIDFILE but the process is not running.
		# This is because it's been killed by something else and hasn't tidied up.
		[[ -e "${PIDFILE}" ]] && _terminate "${SELF} is already running"

		case "${COMMANDTYPE}" in
			work )
				INTERVAL="${3:-10}"

				_say "start work"
				# @todo Can this now be a nohup?
				(sleep "${INTERVAL}" && "${0}" switch > /dev/null 2>&1) &
				_savepid "${!}"
				_setstate "${COMMANDTYPE}" "${COMMAND}" "${INTERVAL}"
				;;
			break )
				INTERVAL="${3:-10}"

				_say "start break"
				(sleep "${INTERVAL}" && "${0}" switch > /dev/null 2>&1) &
				_savepid "${!}"
				_setstate "${COMMANDTYPE}" "${COMMAND}" "${INTERVAL}"
				;;
		esac
		;;
	stop )
		# Deal with the paused state first since it's simpler.
		# @todo Are there any flaws with this approach?
		if [[ -e "${STATEFILE}" && ! -e "${PIDFILE}" ]]
		then
			read -r -p "${SELF} is paused. Are you sure you want to stop it? (y/n) > " C

			if [[ "${C}" =~ ^[yY]$ ]]
			then
				echo "Stopping ${SELF}"
				_rmstate
			else
				echo "Cancelling"
			fi

			exit 0
		fi

		[[ ! -e "${PIDFILE}" ]] && _terminate "${SELF} is not running"
		echo "Stopping ${SELF}"
		_say "Goodbye"
		kill "$(cat ${PIDFILE})"
		_rmpid
		_rmstate
		;;
  switch )
		[[ ! -e "${PIDFILE}" ]] && _terminate "${SELF} is not running"
		_getstate
		_say "stop ${OP}"

		# This might have to do a bit of a switcheroo.
		# Manually get the current pid, then start the new process, and stop the
		# process with the saved pid afterwards to prevent killing itself.
		OLDPID="$(cat ${PIDFILE})"
		_rmpid
		_rmstate
		sleep 3

		# This starts a new pompom process
		case "${OP}" in
		  work )
		  	"${0}" start break
		  	;;
		  break )
				"${0}" start work
				;;
		esac

		# Kill old pompom process
		kill "${OLDPID}"
  	;;
  pause )
		[[ ! -e "${PIDFILE}" ]] && _terminate "${SELF} is not running"
		echo "Pausing ${SELF}"
		kill "$(cat ${PIDFILE})"
		_rmpid
  	_getstate

  	NOW="$(date +%s)"
		_setstate "${OP}" "${COMMAND}" "$(( END - NOW ))"
  	;;
	resume )
		[[ -e "${PIDFILE}" ]] && _terminate "${SELF} is already running"
		[[ ! -e "${STATEFILE}" ]] && _terminate "No state exists to resume"
		_getstate

		[[ "${STATE}" != "pause" ]] && _terminate "${SELF} is not paused. Current state is '${STATE}'"
		echo "Resuming ${OP} with ${REMAINING}s remaining"
		"${0}" start "${OP}" "${REMAINING}"
		;;
	status )
		if [[ -e "${PIDFILE}" ]]
		then
			echo "${SELF} is running"
		else
			echo "${SELF} is not running"
		fi
		;;
	config )
		_terminate "Config doesn't exist yet"
		;;
	* )
		_terminate "'${1}' is not a valid command"
		;;
esac

exit 0
